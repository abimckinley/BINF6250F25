---
title: "Project 06: Hierarchical Clustering"
author: "Abigail McKinley, Jacqueline Caldwell"
date: "`r format(Sys.time(), '%Y%m%d')`"
output:
  github_document:
    html_preview: false
    toc: true
    toc_depth: 2
---

# Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo=TRUE)
library('reticulate')
```

# Imports & Global Variable

```{python}

#Global Variable
EOS = '$' # end of string variable

```

# Learning Objectives
* Students will be able to explain the fundamental principles of the Burrows-Wheeler Transform algorithm, including its purpose, process, and applications in data compression and bioinformatics.
* Students will be able to implement the Burrows-Wheeler Transform using both the naive approach and the more efficient suffix array method.
* Students will be able to construct auxiliary data structures (count array and occurrence array) needed for efficient pattern matching with the FM-Index.
* Students will be able to apply the BWT-based pattern matching algorithm to find exact string matches within a reference text.

#Background
The Burrows-Wheeler Transform (BWT) is a powerful algorithm used in data compression and bioinformatics. Developed by Michael Burrows and David Wheeler in 1994, it rearranges a character string into runs of similar characters, making it more amenable to compression techniques like move-to-front encoding and run-length encoding. Despite adding a small amount of overhead, BWT’s ability to group similar characters together significantly improves compression efficiency.

The BWT works by sorting all possible rotations of a string lexicographically and then extracting the last column of the sorted matrix. What makes BWT remarkable is that this transformation is reversible without storing much additional information - only the position of the original string in the sorted rotations is needed.

In recent years, BWT has found extensive applications beyond compression. It’s particularly valuable in bioinformatics for efficient sequence alignment of DNA reads against reference genomes, as implemented in popular tools like Bowtie and BWA. The algorithm’s efficiency in handling large datasets has made it indispensable for processing the massive amounts of data generated by next-generation sequencing technologies.

## The BWT Algorithm

At its core, the BWT algorithm involves creating all cyclic rotations of an input string, sorting them lexicographically, and then extracting the last column.

Let’s define the pseudocode for our BWT function:

function BWT(string of text)

1.    Append a unique end-of-string character to "string of text" (string_of_text$)
2.    if new_list not present
      Create a new_list to store all possible rotations of the text (2D array len x len)
3.    for each possible starting position in the text do:
         Generate a rotation starting at this position and add to the list
4.    Sort all rotations lexicographically 
5.    Initialize an empty string for the transformed result
6.    for each rotation in the sorted list do
          Append the last character of this rotation to the transformed result (suffix list)
    return(transformed result and ???position of original text in sorted rotations)

```{python}
def BWT(string: str) -> str:
    """Function to calculate Burrows-Wheeler Transform for a given string.
    
    Computes the Burrows-Wheeler Transform by creating all rotations of the input
    string, sorting them lexicographically, and extracting the last column.
    
    Args:
        string: The input string to transform.
    
    Returns:
        The Burrows-Wheeler Transform of the input string.
        
    Examples:
        >>> BWT('googol')
           creates:   googol$
                      $googol
                      l$googo
                      ol$goog
                      gol$goo
                      ogol$go
                      oogol$g
                      
                Sorted:
                      $googol
                      gol$goo
                      googol$
                      l$googo
                      ogol$go
                      ol$goog
                      oogol$g
        
        'lo$oogg'
        
        >>> BWT('banana$')
        'annb$aa'
    """
    pass
```


### Generating BWT from Suffix Arrays

```{python}
def format_text(text:str) -> str:
  '''Function to create the correct format of string needed for suffix_arrays
  
  In order to process properly, suffix_array needs a string of the format stringEOS (string$)
  If $string or string is sent to the function, we are just going to add or move the $;
  otherwise, we will create an error message, and return a null string.
  
  Args:
    text: text string to format/check format
  
  Returns:
    properly formated string for suffix_arrays
  '''
  
  confirm = text.split(EOS)   # check to see if string is of format banana or banana$
  match len(confirm):
    case 1:                      # no EOS marker in string
      text += EOS
    case 2:
      if (confirm[0] == ""):      # EOS at beginning of string; move to end
        text = text[1:] + EOS
      elif (confirm[1] != ""):    # EOS not at end of string
        print(f"format_text(): Invalid string {text}, should be string, $string or string$")
        return("")
    case _:                       # more than one EOS 
      print(f"format_text(): Invalid string {text}, should be string, $string or string$")
      return("")
  return(text)

def suffix_array(text: str) -> list[int]:
  '''Function to calculate suffix-array for a given string.
  
  Computes the suffix array by sorting all suffixes of the input string
  lexicographically and returning their starting positions.
  
  Args: 
    text: The input string to process, of the format "string", "$string" or "string$", 
              where $ is the end of string separator.  If it appears within the string, the
              string will not be processed.
  Returns:
    list of integers:   Representing the the starting positions of the sorted suffixes
  
  '''
  sorted_positions = [] # initialize sorted_list to empty list
  suffix_list = [] # initialize suffix_list to empty list
  

  sequence = format_text(text) # put text in the correct format first with EOS at end of text
  if not (sequence):
      return("")               # error printed by format string already
  
  length = len(sequence)
  
  for i in range(length):
    suffix_list.append((sequence[i:],i)) #create list of suffixes paired with starting pos
    
  suffix_list.sort() # suffix list will now be sorted by first item in tuple - suffix
    
  for i in range(length):
    sorted_positions.append(suffix_list[i][1]) # append original position in string to list
    
  return(sorted_positions)  
      
# Testing code.  DELETE THIS SECTION BEFORE PROJECT IS DUE
str1 = "googol$"
list1 = suffix_array(str1)
print(f"{str1} sent to suffix_array found {list1}; should be [6, 3, 0, 5, 2, 4, 1]")
str2 = "googol"
list1 = suffix_array(str2)
print(f"{str2} sent to suffix_array found {list1}; should be [6, 3, 0, 5, 2, 4, 1]")
str3 = 'banana$'
list1 = suffix_array(str3)
print(f"{str3} sent to suffix_array found {list1}; should be [6, 5, 3, 1, 0, 4, 2]")
str4 = 'banana'
list1 = suffix_array(str4)
print(f"{str4} sent to suffix_array found {list1}; should be [6, 5, 3, 1, 0, 4, 2]")
str5 = '$banana'
list5 = suffix_array(str5)
print(f"{str5} sent to suffix_array found {list5}; should be [6, 5, 3, 1, 0, 4, 2]")
str6 = 'goo$gol'
list6 = suffix_array(str6)
print(f"{str6} - should have generated error message, not in right format")
```
    
Once we have a suffix array, we can compute the BWT more efficiently:


```{python}
def BWT_from_suffix_array(text: str, suffix_positions: list[int] ) -> str:
  '''Function to calculate the Burrows-Wheeler Transform from a suffix array.
  
  Computes the Burrows-Wheeler Transform by using the suffix array to identify
  the character that preceds each suffix in the sorted order.
  
  Args:
      text: The input string to transform.
      suffix_positions: The suffix array for the input string, containing the
                        starting positions of all of the suffixes in lexicographical
                        order.
                        
  Returns:
      The Burrows-Wheeler Transform of the input string.
      
    #Examples:
      #  >>> BWT_from_suffix_array("banana$", [6, 5, 3, 1, 0, 4, 2])
      #  'annb$aa'
        
       # >>> BWT_from_suffix_array("googol$", [6, 3, 0, 5, 2, 4, 1])
      #  'lo$oogg'
  '''  

  text_str = format_text(text) # put text in the correct format first with EOS at end of text.
  if not (text_str):
      return("")               # error printed by format string already
  
  length = len(text_str)
  
  transformed =[' ']*length    # initial list of size length with char 'space' in all
  
  for i in range(length):
      transformed[i] = text_str[suffix_positions[i]-1]
       
  return("".join(transformed))

# for Code Testing    DELETE BEFORE PROJECT IS DUE
str1 = "banana$"
suffix1 = suffix_array(str1)
BWT1 = BWT_from_suffix_array(str1, suffix1)
print(f"BWT_from_suffix_array {str1}, {suffix1}, {BWT1}, should be: banana$,[6, 5, 3, 1, 0, 4, 2],annb$aa")
str2 = "googol$"
suffix2 = suffix_array(str2)
BWT2 = BWT_from_suffix_array(str2,suffix2)
print(f"BWT_from_suffix_array {str2}, {suffix2}, {BWT2}, should be: googol$, [6, 3, 0, 5, 2, 4, 1]), lo$oogg")

str3 = "banana" # NEED TO FIX THIS TEST CASE!!!   no $ in BWT string????
suffix3 = suffix_array(str3)
BWT3 = BWT_from_suffix_array(str3,suffix3)
print(f"BWT_from_suffix_array {str3}, {suffix3}, {BWT3}, should be: banana$,[6, 5, 3, 1, 0, 4, 2],annb$aa")

str4 = "$banana" # NEED TO FIX THIS TEST CASE!!! check what encoded result should be
suffix4 = suffix_array(str4)
BWT4 = BWT_from_suffix_array(str4,suffix4)
print(f"BWT_from_suffix_array {str4}, {suffix4}, {BWT4}, should be: $banana, [6, 5, 3, 1, 0, 4, 2],annb$aa")

```

## FM-Index for Pattern Matching
The BWT becomes particularly powerful when combined with auxiliary data structures to form an FM-Index, which enables efficient pattern matching. Two key components are the count and occurrence arrays.

The FM-index is a compressed full-text index data structure that combines the Burrows-Wheeler Transform (BWT) with auxiliary data structures to enable efficient pattern matching while maintaining a small memory footprint. Developed by Paolo Ferragina and Giovanni Manzini (hence the name “FM”), it’s sometimes referred to as “Full-text Minute-space” index.

FM-index BWT with auxiliary data structures top enable efficient pattern matching with small memory footpring.

###Core Components
The FM-index consists of several key components:

Last_col (BWT) - permutation of original text grouping similar characters together

First_col (F) - array of |Σ| integers (where Σ is the alphabet),     ???? abcd or GCTA or aa list?
                   (or sometimes not stored at all as it can be derived)

Count_arr (C) - Stores number of char lexicographically smaller than each character in the alphabet
          Example ( 'A': 0, 'C': 1, 'G': 2, 'T': 3).   ???? I think.

Occurrence_table (OT) - How many times each char appears "up to each position" in BWT

Suffix_Array (SA) sample - A subset of the suffix array positions, often stored at regular intervals to save space

###Functions
The FM-index supports several fundamental operations:

Count - Returns #of occurrences of a pattern in the text, where p is the pattern length

Locate - Returns the positions of all occurrences of ????string???? in the text

Backward_search - Core algo that enables efficient pattern matching by traversing the pattern from right to left

LF_mapping - A procedure that maps positions in the Last (L) column to corresponding positions in the First (F) column

### Advantages
The FM-index offers several notable benefits:

Space efficiency - Occupies space close to the entropy of the indexed text, typically 5nHk(T) + o(n) bits, where Hk(T) is the k-th order entropy

Query performance - Allows searching for pattern occurrences in O(p + occ log^(1+ε) n) time, where occ is the number of occurrences

Self-indexing - Encapsulates the indexed data, allowing reconstruction of the original text without storing it separately

Compression - Takes advantage of the compressibility of the indexed data

Partial decompression - Only decompresses tiny portions of the compressed file during queries

The FM-index has become particularly important in bioinformatics for efficient DNA and protein sequence alignment, forming the basis of popular tools like Bowtie and BWA that handle massive genomic datasets.

### The implementation
One of the key parts for string matching is to do Last-to-First column mapping (LF mapping) within the BWT matrix. With the LF property, we need to build two dictionaries for our reference string beforehand:

LF property => Last, First property 

count: e.g. {'A': 0, 'C': 2, 'G': 3, 'T': 5}
Where for each character a in a string, count[a] contains the number of instances of characters in string that are lexicographically smaller than a.

occur: {'$': [0, 0, 1, 1, 1], 'A': [1, 1, 1, 1, 1], 'C': [0, 0, 0, 1, 1], 'G': [0, 1, 1, 1, 2]}
Where for each character a in a bwt string, occur[a][i] contains the number of occurences of a in bwt_string[0,i], i=1,...,len(bwt_string) (i.e. the first i characters in bwt string).

With those two dictionaries, we can then start matching the query string to our reference string.

Count Array
The count array stores the number of characters lexicographically smaller than each character in the alphabet:

function calculate_counts(transformed, alphabet)
  Initialize a dictionary to track character counts create dict with alphabet as key
  Initialize a result dictionary for cumulative counts create dict with alphabet as key
  Set initial cumulative count to zero
  for each character in the sorted alphabet do
    Store the current cumulative count for this character
    Increase the cumulative count by the frequencey of this character
  return(the dictionary of cumulative counts)
  
```{python}
from collections import Counter

def cal_count(string: str) -> dict[str, int]:
    """Function to count characters lexicographically smaller than each character.
    
    For each character in the alphabet, calculates how many characters in the
    input string are lexicographically smaller than it.
    
    Args:
        string: The input string to analyze.
    
    Returns:
        A dictionary mapping each character to the count of characters
        lexicographically smaller than it.
    
    Examples:
        >>> cal_count('ATGACG')
        {'A': 0, 'C': 2, 'G': 3, 'T': 5}
        
        >>> cal_count('banana')
        {'a': 0, 'b': 3, 'n': 4}
    """
    pass
```

Occurrence Array
The occurrence array tracks how many times each character appears up to each position in the BWT:

function cal_occur (transformed, alphabet)
  Initialize a dictionary mapping each character to an array of zeros
  for each position in the transformed text do
    Identify the character at the current position
    copy the previous occurance count to the current position
    Increment the occurrence count for the current character
  return(dictionary of occurrence counts)
  

```{python}
def cal_occur(bwt_string: str) -> dict[str, list[int]]:
    """Function to calculate occurrences of each character up to each position.
    
    For each character and each position i, calculates how many times the
    character appears in the substring bwt_string[0:i].
    
    Args:
        bwt_string: The BWT string to analyze.
    
    Returns:
        A dictionary mapping each character to a list of occurrence counts,
        where occur[char][i] is the number of occurrences of char in
        bwt_string[0:i].
    
    Examples:
        >>> cal_occur('AG$CG')
        {'$': [0, 0, 1, 1, 1], 'A': [1, 1, 1, 1, 1], 'C': [0, 0, 0, 1, 1], 'G': [0, 1, 1, 1, 2]}
        
        >>> cal_occur('annb$aa')
        {'$': [0, 0, 0, 0, 1, 1, 1], 'a': [0, 1, 1, 1, 1, 2, 3], 'b': [0, 0, 0, 1, 1, 1, 1], 'n': [0, 0, 2, 2, 2, 2, 2]}
    """
    pass
```

###Pattern Matching with BWT

Alignments using BWT
With the BWT and auxiliary structures in place, we can efficiently find pattern matches using backward search:

function update_range(character(a), range_start(upper), range_end(lower), counts(count), occurances(occur))
  Calculate new start position (upper) using character's count and occurrences at range start
  Calculate new end position using character's count and occurrences at range end
  return(new_start (new_upper), new_end (new_lower) (AS TUPLE))

```{python}
def update_range(
  lower: int, 
  upper: int, 
  count: dict[str, int], 
  occur: dict[str, list[int]], 
  a: str) -> tuple[int, int]:
    """Function to update range given character a.
    
    Updates the search range during backward search in the BWT pattern matching
    algorithm when processing character a.
    
    Args:
        lower: The lower boundary of the current range.
        upper: The upper boundary of the current range.
        count: Dictionary mapping each character to the count of lexicographically
            smaller characters.
        occur: Dictionary mapping each character to its occurrence counts at each
            position.
        a: The character being processed in the pattern.
    
    Returns:
        A tuple containing the updated lower and upper boundaries of the range.
    
    Note:
        This function assumes occur[a][-1] = 0 for boundary conditions.
    """
    pass
```

function find_match(pattern (query),transformed,counts,occurrences, suffix_positions) 
  Initialize search range to cover the entire transformed text
  for each character in the 'pattern', processing from right to left do
    Update the search range based on the current character
    if the range becomes empty then
      return "" # empty list as pattern is not found
    Collect all suffix positions within the final range
  return (list of matching positions)

```{python}
def find_match(query: str, reference: str) -> list[int]: ##????  I'm comfused, why does pseudocode not match here????
    """Function to find exact matching by applying Burrows-Wheeler Transform.
    
    Searches for all occurrences of the query string within the reference string
    using the Burrows-Wheeler Transform algorithm for efficient pattern matching.
    
    Args:
        query: The pattern string to search for.
        reference: The text string to search within.
    
    Returns:
        A list of integers representing the 0-based starting positions of all
        occurrences of the query string within the reference string. Returns an
        empty list if no matches are found.
    
    Examples:
        >>> find_match('ana', 'banana')
        [1, 3]
        
        >>> find_match('xyz', 'banana')
        []
    """
    pass
```

###Tricky Parts to Watch Out For
End-of-string character: Ensure your implementation includes a unique end-of-string character (often ‘$’) that doesn’t appear elsewhere in the string. This character should typically be lexicographically smaller than all other characters.    

Suggest global EOS = '$' to allow -- discussed and added.

Indexing issues: Pay careful attention to zero-based versus one-based indexing, especially when implementing the BWT from suffix arrays.  ????

Edge cases: Handle edge cases properly, such as when the suffix array index is 0, or when dealing with empty strings or patterns.   ????

Performance considerations: The naive BWT implementation is \(O(n^2 \log n)\) due to sorting n strings of length n. Using suffix arrays reduces this to \(O(n \log n)\).

Memory usage: For large strings, storing all rotations can be memory-intensive. The suffix array approach is more memory-efficient.

```{python}
#main function/testing goes here.

```